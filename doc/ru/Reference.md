# Справка

## Пространство имён

Классы UPL находятся в пространстве имён `upl`.

Далее в [Справке](#Справка) подразумевается, что все упоминаемые классы находятся в `upl`, иначе пространства имён указываются явно.

## Указатели

UPL предоставляет следующий набор указателей с заданным типом [владения](TheoreticalBasis.md#Владение):
* `unique` - владеет объектом уникально;
* `shared` - владеет объектом совместно;
* `unified` - ссылается на объект, который может находиться в уникальном или совместном владении другого указателя;
* `weak` - хранит невладеющую ссылку на объект, который находится в уникальном или совместном владении другого указателя.

Также, для каждого типа владения определены указатели с суффиксами `_optional` и `_single`, с опциональной и одинарной [кратностью](TheoreticalBasis.md#Кратность) соответственно.

Публичный API указателей `unique`, `shared` и `weak` совпадает с API `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr` (см. подробности в [отличиях от указателей С++](#Отличия-от-умных-указателей-c17) и [TODO](#todo)). Интерфейс и поведение указателя `unified` больше всего похожи на `shared`.

## Концепты указателей

Концепты ([Concepts](http://en.cppreference.com/w/cpp/language/constraints)) описываются в виде требований к указателям и позволяют определять, какому типу [владения](TheoreticalBasis.md#Владение) или [кратности](TheoreticalBasis.md#Кратность) соответствует указатель. Концепты используются в шаблонных методах класса и функциях для выбора специализации по типу параметра, а также в операторе `if constexpr`.

В UPL определены следующие концепты:

* по принадлежности к типу владения:

| Концепт          | Тип владения  | Указатели                     |
|------------------|---------------|-------------------------------|
| `Pointer`        | `owner_based` | все указатели                 |
| `StrongPointer`  | `strong`      | `unified`, `unique`, `shared` |
| `WeakPointer`    | `weak`        | `weak`                        |
| `UnifiedPointer` | `unified`     | `unified`                     |
| `StrictPointer`  | `strict`      | `unique`, `shared`            |
| `UniquePointer`  | `unique`      | `unique`                      |
| `SharedPointer`  | `shared`      | `shared`                      |

* по принадлежности к типу кратности:

| Концепт           | Тип кратности | Указатели                                                    |
|-------------------|---------------|--------------------------------------------------------------|
| `OptionalPointer` | `optional`    | `unified`, `unique`, `shared`, `weak` <br /> `xxxx_optional` |
| `SinglePointer`   | `single`      | `xxxx_single`                                                |

## Область применения

Основным предназначением указателей UPL является организация [ассоциативных связей](TheoreticalBasis.md#Ассоциативные-связи) между объектами при написании программ в парадигме ООП для многопоточной среды.

__Указатели UPL `unique`, `shared` и `weak` рекомендуется использовать в полях класса__ для формирования связи, которая обладает заданными типом [владения](TheoreticalBasis.md#Владение) и [кратностью](TheoreticalBasis.md#Кратность), с другими объектами. __Указатель `unified` рекомендуется использовать в параметрах функции и локальных переменных, и крайне НЕ рекомендуется использовать в полях класса для связи с объектами__. [Подробнее](TheoreticalBasis.md#Свойства-параметры-и-переменные).

## Отличия от умных указателей C++17

Указатели UPL повторяют функциональность умных указателей стандартной библиотеки С++17 и расширяют её. Интерфейсы указателей UPL очень схожи с интерфейсами умных указателей стандартной библиотеки С++. Указатели UPL не совместимы с умными указателями стандартной библиотеки C++, т.е. объект, находящийся под управлением указателя одной библиотеки, нельзя напрямую передать под управление указателю другой библиотеки. Передать объект можно только предварительно "освободив" (release) его в "сырой" (raw) указатель, который затем можно передать умному указателю другой библиотеки.

Ниже перечислены отличия указателей UPL от умных указателей стандартной библиотеки С++17, которые имеются на текущий момент. Большую часть отсутствующих возможностей необходимо добавить.

* `unique`:
  * отсутствует `Deleter`;
  * отсутствует `operator[]`;
  * отсутствует метод `release()`;
  * отсутствует аналог функции `std::make_unique(Args&&... args)`;
  * добавлен конструктор `unique(std::in_place_t, Args&&... args)`.
* `shared`:
  * отсутствуют конструкторы с `Deleter` и `Allocator`;
  * отсутствует *aliasing constructor*;
  * отсутствует `operator[]`;
  * отсутствует метод `use_count()`;
  * отсутствует аналог функции `std::make_shared(Args&&... args)`;
  * отсутствует аналог функции `std::allocate_shared(Args&&... args)`;
  * добавлен конструктор `shared(std::in_place_t, Args&&... args)`;
  * отсутствует аналог `std::enable_shared_from_this`.
* `weak`:
  * отсутствует метод `use_count()`.

## TODO

1. Сделать реализацию указателей потокобезопасной.
2. Добавить функции преобразования указателей (`static_cast`, `dynamic_cast`).
3. Добавить в реализацию поддержку `Allocator` и `Deleter`.
