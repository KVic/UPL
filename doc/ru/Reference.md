# Справка

## Пространство имён

Классы UPL находятся в пространстве имён `upl`.

Далее в [Справке](#Справка) подразумевается, что все упоминаемые классы находятся в `upl`, иначе пространства имён указываются явно.

## Указатели

UPL предоставляет следующий набор указателей с заданным типом [владения](TheoreticalBasis.md#Владение):
* `unique` - владеет объектом уникально;
* `shared` - владеет объектом совместно;
* `unified` - ссылается на объект, который может находиться в уникальном или совместном владении другого указателя;
* `weak` - хранит невладеющую ссылку на объект, который находится в уникальном или совместном владении другого указателя.

Также, для каждого типа владения определены указатели с суффиксами `_optional` и `_single`, с опциональной и одинарной [кратностью](TheoreticalBasis.md#Кратность) соответственно.

Публичный API указателей `unique`, `shared` и `weak` совпадает с API `std::unique_ptr`, `std::shared_ptr` и `std::weak_ptr` (см. подробности в [отличиях от указателей С++](#Отличия-от-умных-указателей-c17) и [TODO](#todo)). Интерфейс и поведение указателя `unified` больше всего похожи на `shared`.

## Концепты указателей

Концепты ([Concepts](http://en.cppreference.com/w/cpp/language/constraints)) описываются в виде требований к указателям и позволяют определять, какому типу [владения](TheoreticalBasis.md#Владение) или [кратности](TheoreticalBasis.md#Кратность) соответствует указатель. Концепты используются в шаблонных методах класса и функциях для выбора специализации по типу параметра, а также в операторе `if constexpr`.

В UPL определены следующие концепты:

* по принадлежности к типу владения:

| Концепт          | Тип владения  | Указатели                     |
|------------------|---------------|-------------------------------|
| `Pointer`        | `owner_based` | все указатели                 |
| `StrongPointer`  | `strong`      | `unified`, `unique`, `shared` |
| `WeakPointer`    | `weak`        | `weak`                        |
| `UnifiedPointer` | `unified`     | `unified`                     |
| `StrictPointer`  | `strict`      | `unique`, `shared`            |
| `UniquePointer`  | `unique`      | `unique`                      |
| `SharedPointer`  | `shared`      | `shared`                      |

* по принадлежности к типу кратности:

| Концепт           | Тип кратности | Указатели                                                    |
|-------------------|---------------|--------------------------------------------------------------|
| `OptionalPointer` | `optional`    | `unified`, `unique`, `shared`, `weak` <br /> `xxxx_optional` |
| `SinglePointer`   | `single`      | `xxxx_single`                                                |

## Область применения

Основным предназначением указателей UPL является организация [ассоциативных связей](TheoreticalBasis.md#Ассоциативные-связи) между объектами при написании программ в парадигме ООП для многопоточной среды.

__Указатели UPL `unique`, `shared` и `weak` рекомендуется использовать в полях класса__ для формирования связи, которая обладает заданными типом [владения](TheoreticalBasis.md#Владение) и [кратностью](TheoreticalBasis.md#Кратность), с другими объектами. __Указатель `unified` рекомендуется использовать в параметрах функции и локальных переменных, и крайне НЕ рекомендуется использовать в полях класса для связи с объектами__. [Подробнее](TheoreticalBasis.md#Свойства-параметры-и-переменные).

## Отличия от умных указателей C++17

Указатели UPL повторяют функциональность умных указателей стандартной библиотеки С++17 и расширяют её. Текущая реализация указателей UPL выполнена в виде обёрток над стандартными указателями (`upl::unique/shared/unified` - обёртки над `std::shared_ptr`, `upl::weak` - обёртка над `std::weak_ptr`) и обладают такой же производительностью. Интерфейсы указателей UPL очень схожи с интерфейсами умных указателей стандартной библиотеки С++ и возможно взаимное преобразование между ними. Можно создать:
* `upl::unique` из `std::unique_ptr`;
* `upl::shared` из `std::unique_ptr/shared_ptr/weak_ptr`;
* `upl::unified` из `std::unique_ptr/shared_ptr/weak_ptr`;
* `upl::weak` из `std::shared_ptr/weak_ptr`;
* `std::shared_ptr` из `upl::shared`.

Ниже перечислены отличия указателей UPL от умных указателей стандартной библиотеки С++17, которые имеются на текущий момент. Большую часть отсутствующих возможностей необходимо добавить.

* `unique`:
  * отсутствует параметр шаблона `Deleter`, но можно создать указатель из `std::unique_ptr<T, Deleter>`;
  * отсутствует `operator[]`;
  * отсутствует метод `release()`;
  * добавлен конструктор `unique(upl::itself_t, Args&&... args)`, который работает аналогично функции `std::make_unique<T>(Args&&... args)`.
* `shared`:
  * отсутствуют конструкторы с `Deleter` и `Allocator`, но можно создать указатель из `std::shared_ptr` с такими конструкторами;
  * отсутствует *aliasing constructor*, но можно создать указатель из `std::shared_ptr` с таким конструктором;
  * отсутствует `operator[]`;
  * отсутствует метод `use_count()`;
  * добавлен конструктор `shared(upl::itself_t, Args&&... args)`, который работает аналогично функции `std::make_shared<T>(Args&&... args)`;
  * отсутствует аналог `std::enable_shared_from_this`;
  * нельзя создать `upl::shared` из `upl::weak`.
* `weak`:
  * метод `lock()` возвращает `upl::unified`, а не `upl::shared`;
  * отсутствует метод `use_count()`.

## TODO

1. Добавить функции преобразования указателей (`static_cast`, `dynamic_cast`).
2. Добавить конструкторы c `Allocator` и `Deleter`.
3. Сделать `upl::enable_weak_from_this`.
